# coding: utf-8

"""
    Cloud Speech-to-Text API

    Converts audio to text by applying powerful neural network models. <br> **PLEASE NOTE**: This API is provided by Google, beside the documentation provide below, you can find Google API documentation [here](https://cloud.google.com/speech-to-text/docs/reference/rest). You can refer to the Google documentation as well except by the URLs needed to call the API and that are documented here below.  # noqa: E501

    OpenAPI spec version: v3.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class WordInfo(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'word': 'str',
        'speaker_tag': 'int',
        'end_time': 'str',
        'start_time': 'str'
    }

    attribute_map = {
        'word': 'word',
        'speaker_tag': 'speakerTag',
        'end_time': 'endTime',
        'start_time': 'startTime'
    }

    def __init__(self, word=None, speaker_tag=None, end_time=None, start_time=None):  # noqa: E501
        """WordInfo - a model defined in Swagger"""  # noqa: E501
        self._word = None
        self._speaker_tag = None
        self._end_time = None
        self._start_time = None
        self.discriminator = None
        if word is not None:
            self.word = word
        if speaker_tag is not None:
            self.speaker_tag = speaker_tag
        if end_time is not None:
            self.end_time = end_time
        if start_time is not None:
            self.start_time = start_time

    @property
    def word(self):
        """Gets the word of this WordInfo.  # noqa: E501

        The word corresponding to this set of information.  # noqa: E501

        :return: The word of this WordInfo.  # noqa: E501
        :rtype: str
        """
        return self._word

    @word.setter
    def word(self, word):
        """Sets the word of this WordInfo.

        The word corresponding to this set of information.  # noqa: E501

        :param word: The word of this WordInfo.  # noqa: E501
        :type: str
        """

        self._word = word

    @property
    def speaker_tag(self):
        """Gets the speaker_tag of this WordInfo.  # noqa: E501

        Output only. A distinct integer value is assigned for every speaker within the audio. This field specifies which one of those speakers was detected to have spoken this word. Value ranges from '1' to diarization_speaker_count. speaker_tag is set if enable_speaker_diarization = 'true' and only in the top alternative.  # noqa: E501

        :return: The speaker_tag of this WordInfo.  # noqa: E501
        :rtype: int
        """
        return self._speaker_tag

    @speaker_tag.setter
    def speaker_tag(self, speaker_tag):
        """Sets the speaker_tag of this WordInfo.

        Output only. A distinct integer value is assigned for every speaker within the audio. This field specifies which one of those speakers was detected to have spoken this word. Value ranges from '1' to diarization_speaker_count. speaker_tag is set if enable_speaker_diarization = 'true' and only in the top alternative.  # noqa: E501

        :param speaker_tag: The speaker_tag of this WordInfo.  # noqa: E501
        :type: int
        """

        self._speaker_tag = speaker_tag

    @property
    def end_time(self):
        """Gets the end_time of this WordInfo.  # noqa: E501

        Time offset relative to the beginning of the audio, and corresponding to the end of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.  # noqa: E501

        :return: The end_time of this WordInfo.  # noqa: E501
        :rtype: str
        """
        return self._end_time

    @end_time.setter
    def end_time(self, end_time):
        """Sets the end_time of this WordInfo.

        Time offset relative to the beginning of the audio, and corresponding to the end of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.  # noqa: E501

        :param end_time: The end_time of this WordInfo.  # noqa: E501
        :type: str
        """

        self._end_time = end_time

    @property
    def start_time(self):
        """Gets the start_time of this WordInfo.  # noqa: E501

        Time offset relative to the beginning of the audio, and corresponding to the start of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.  # noqa: E501

        :return: The start_time of this WordInfo.  # noqa: E501
        :rtype: str
        """
        return self._start_time

    @start_time.setter
    def start_time(self, start_time):
        """Sets the start_time of this WordInfo.

        Time offset relative to the beginning of the audio, and corresponding to the start of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.  # noqa: E501

        :param start_time: The start_time of this WordInfo.  # noqa: E501
        :type: str
        """

        self._start_time = start_time

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(WordInfo, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, WordInfo):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
